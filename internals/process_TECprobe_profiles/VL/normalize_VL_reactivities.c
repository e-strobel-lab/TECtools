//
//  normalize_VL_reactivities.c
//  
//
//  Created by Eric Strobel on 2/16/24.
//

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "../../global/global_defs.h"
#include "../../utils/debug.h"
#include "../../utils/io_management.h"
#include "../../utils/gen_utils.h"

#include "../../mkmtrx/cotrans_mtrx.h"
#include "../../mkmtrx/mkmtrx_defs.h"

#include "./process_TECprobeVL_profiles_defs.h"
#include "./process_TECprobeVL_profiles_structs.h"

#include "../global/store_SM2_profile.h"
#include "../global/calculate_normalization_factor.h"

#include "normalize_VL_reactivities.h"

/* normalize_VL_reactivities: generate normalization factor using whole data set and normalize reactivity values */
void normalize_VL_reactivities(SM2_analysis_directory * an_dir, int min_depth, double max_bkg, int norm_all, int verify_norm)
{
    extern int debug; //flag to run debug mode
    
    int i = 0;          //general purpose index
    int j = 0;          //general purpose index
    
    //reactivity filtering variables
    int tot_rct_pf = 0;                   //total reactivity values that pass filter
    int tl_lt_100 = 0;                    //reactivity values from transcripts w/ length <100
    int tl_gtoe_100 = 0;                  //reactivity values from transcripts w/ length >=100
    int * p_tl100_tracking = NULL;        //pointer to use for tracking tl reactivity vals
    int pct2use = 0;                      //
    double * reactivity_list = NULL;      //list of reactivity values that passed filter
    
    //normalization accuracy testing variables
    //used to recalculate normalized reactivity
    //values for individual transcript lengths
    int cl_rct_pf = 0;                    //current length reactivities passed filter
    double * cl_reactivity_list = NULL;   //current length reactivity list
    double cl_norm_factor = 0;            //current length normalization factor
    int test_failed = 0;                  //flag that test failed
    
    //allocate memory for the reactivity list
    reactivity_list = calloc(an_dir->trg_rct_cnt, sizeof(*reactivity_list));
    
    //for each transcript length, copy reactivity values
    //that pass filter to the reactivity list
    for (i = an_dir->min_tl, tot_rct_pf = 0; i <= an_dir->max_tl; i++) {
        
        //in verify_norm mode, reset variables for recalculating individual normalization factors
        if (verify_norm) {
            test_failed = 0;                  //reset failure flag to 0
            cl_rct_pf = 0;                    //reset current length reactivites passed filter to 0
            cl_norm_factor = 0;               //resent normalization factor to 0
            if (cl_reactivity_list != NULL) { //free previously allocated rct list memory
                free(cl_reactivity_list);
            }
            cl_reactivity_list = calloc(1024, sizeof(*reactivity_list)); //allocate rct list memory
        }

        //set pointer for tracking the number of reactivity
        //values from transcript lengths <100 and >=100
        if (an_dir->data[i].trg_nt_cnt < 100) {
            p_tl100_tracking = &tl_lt_100;
        } else {
            p_tl100_tracking = &tl_gtoe_100;
        }
        
        //copy reactivity values that pass filter to the reactivity list
        for (j = 0; j < an_dir->data[i].tot_nt_cnt; j++) {
            
            if (isHQnuc(&an_dir->data[i], j, min_depth, max_bkg)) {
                
                //reactivity value passed filter, copy to reactivity list
                //and increment tracking variable
                reactivity_list[tot_rct_pf++] = an_dir->data[i].reactivity_profile[j];
                (*p_tl100_tracking)++;
                
                //in verify_norm mode, add pf reactivity to list for the current transcript len
                if (verify_norm) {
                    cl_reactivity_list[cl_rct_pf++] = an_dir->data[i].reactivity_profile[j];
                }
            }
        }
        
        //in verify_norm mode, re-normalize all reactivity values and compare to the
        //normalized reactivity values generated by shapemapper2
        if (verify_norm) {
            
            //calculate a normalization factor for the current transcript length
            cl_norm_factor = calculate_normalization_factor(&cl_reactivity_list[0], cl_rct_pf, (an_dir->data[i].trg_nt_cnt < 100) ? PCT95TH: PCT90TH);
                        
            for (j = 0; j < an_dir->data[i].tot_nt_cnt; j++) { //for each nucleotide...
                
                //calculate a new normalized reactivity value
                if (isnan(an_dir->data[i].hq_profile[j])) {
                    
                    //if HQ reactivity is NaN set recalced value to NaN
                    an_dir->data[i].recalc_norm_profile[j] = NAN;
                } else {
                    //otherwise divide reactivity by current length normalization factor
                    an_dir->data[i].recalc_norm_profile[j] = an_dir->data[i].reactivity_profile[j]/cl_norm_factor;
                }
                
                //if recalculated normalized reactivity does not match the
                //value that was originally calculated by shapemapper2, set
                //test_failed variable to TRUE
                if (!compare_float(an_dir->data[i].norm_profile[j], an_dir->data[i].recalc_norm_profile[j], 0.000001) && !isnan(an_dir->data[i].hq_profile[j])) {
                    test_failed = 1;
                }
            }
            
            //in debug mode, print failure/success message
            if (verify_norm) {
                printf("tl %3d, cnf = %12.8f\t", an_dir->data[i].trg_nt_cnt, cl_norm_factor);
                if (test_failed) {
                    printf("ERROR\nrecalculated normalized profiles are discordant. please check that min depth and max background match the values used during analysis. if they do match and normalization verification still fails, please contact estrobel@buffalo.edu. aborting...\n\n");
                } else {
                    printf("full match\n");
                }
            }
        }
    }
    
    //if more reactivity values were present in transcripts >= 100,
    //use 90th percentile, otherwise use 95th percental
    pct2use = (tl_gtoe_100 >= tl_lt_100) ? PCT90TH : PCT95TH;
    
    //calculate whole data set normalization factor
    an_dir->cnf = calculate_normalization_factor(&reactivity_list[0], tot_rct_pf, pct2use);
    
    //if running debug mode, print information about reactivity counts and
    //print the whole data set normalization factor
    if (debug) {
        printf("%d reactivities copied\n", tot_rct_pf);
        printf("%d reactivities from tl <100\n", tl_lt_100);
        printf("%d reactivities from tl >=100\n", tl_gtoe_100);
        printf("cnf = %.10f\n\n", an_dir->cnf);
    }
    
    //apply whole dataset normalization factor
    for (i = an_dir->min_tl; i <= an_dir->max_tl; i++) {
        for (j = 0; j < an_dir->data[i].tot_nt_cnt; j++) {
            
            //only apply normalization factor to high-quality nucleotides
            //low quality nucleotides are masked as NAN unless norm_all
            //option is on
            if (isHQnuc(&an_dir->data[i], j, min_depth, max_bkg) || norm_all) {
                an_dir->data[i].dataset_norm_profile[j] = an_dir->data[i].reactivity_profile[j]/an_dir->cnf;
            } else {
                an_dir->data[i].dataset_norm_profile[j] = NAN;
            }
            
            //set all dataset_norm_stderr values to NAN, since it is not calculated
            an_dir->data[i].dataset_norm_stderr[j] = NAN;
        }
    }
    
    return;
}


