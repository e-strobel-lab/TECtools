//
//  print_output.c
//  
//
//  Created by Eric Strobel on 8/29/24.
//

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "../global/global_defs.h"
#include "../global/global_structs.h"

#include "../seq_utils/basemap.h"

#include "./variant_maker_defs.h"
#include "./variant_maker_structs.h"

#include "print_output.h"

/* print_output: print variants (without barcode) to output file */
void print_output(names * nm, basemap * bmap, int vTmpCnt, int varCnt, char * out_dir, int append_priming, int append_barcode, FILE * fp_brcd, int first_bc_2_use, char * cstm_lnkr, int make_fasta)
{
    extern fasta *vrnts;    //array of variant sequences
    extern uint64_t v_indx; //index for vrnts array
    
    int i = 0; //general purpose index
    int j = 0; //general purpose index
    int k = 0; //general purpose index
    int c = 0; //constant insertion index
    int d = 0; //constant deletion index
    
    int ret = 0;          //variable for storing snprintf return value
    int printed_vb = 0;   //flag that first vb of a variant template was printed
    int filtered_tot = 0; //total number of variants after filtering
    
    int trgs_per_ref = 0; //targets made per reference sequence
    int bcs_per_var = 3;  //number of barcodes assigned to each variant //TODO: make option?
    
    for (i = 0; i < MAXREF; i++) {
        filtered_tot += bmap[i].cnt[FILTERED];
    }
    
    char checkname[MAX_LINE] = {0};
    char vb_nm[MAX_VBASE_NAME_FIELD+1]={0}; //array for assembling variant attributes during name construction
    
    FILE * out_fp = NULL;        //output file pointer
    char out_nm[MAX_LINE] = {0}; //output file name
    
    //construct variant output file name
    ret = snprintf(out_nm, MAX_LINE, "./%s/%s_variants.txt", out_dir, nm->vTmp);
    if (ret >= MAX_LINE || ret < 0) {
        printf("print_output: error - error when constructing variant output file name. aborting...\n");
        abort();
    }
    
    //generate output file
    if ((out_fp = fopen(out_nm, "w")) == NULL) {
        printf("print_output: ERROR - could not generate variants output file. aborting...\n");
        abort();
    }
    
    FILE * fasta_fp = NULL;        //fasta file pointer
    char fasta_nm[MAX_LINE] = {0}; //fasta file name
    
    if (make_fasta) {
        //construct variant fasta file name and generate fasta file
        ret = snprintf(fasta_nm, MAX_LINE, "./%s/%s_variants.fa", out_dir, nm->vTmp);
        if (ret >= MAX_LINE || ret < 0) {
            printf("print_output: error - error when constructing variant fasta file name. aborting...\n");
            abort();
        }

        if ((fasta_fp = fopen(fasta_nm, "w")) == NULL) {
            printf("print_output: ERROR - could not generate variants fasta file. aborting...\n");
            abort();
        }
    }
    
        
    fprintf(out_fp, "variants:%d\n", filtered_tot); //print the number of variants in the output file (excluding reference variants)
    
    fprintf(out_fp, "WT:%s\t%s\n", bmap[0].wt->nm, bmap[0].wt->sq); //print wt name and sequence
    
    //print variants to the output file
    for (i = 0, j = 0; i < v_indx; i++) {
        if (strstr(vrnts[i].nm, "REF") != NULL) {
            
            //printing a reference sequence, append the number of targets
            //that were generated by that reference to "REF"
            if (j < vTmpCnt) { //check that basemap array bounds are not exceeded
                
                sprintf(checkname, "REF:%s_%s", bmap[j].wt->nm, bmap[j].nm);
                if (strcmp(vrnts[i].nm, checkname)) {
                    printf("print_output: error - unexpected reference target name. aborting...\n");
                    abort();
                }
                
                //print number of targets produced from the current reference sequence
                if (append_barcode) { //if appending barcodes, multiply by barcode replicates
                    trgs_per_ref = bmap[j].cnt[FILTERED] * bcs_per_var;
                } else { //otherwise, just used filtered variant count
                    trgs_per_ref = bmap[j].cnt[FILTERED];
                }
                fprintf(out_fp, "%s|TPR:%d", vrnts[i].nm, trgs_per_ref); //print targets per ref
                
                //print list of variable bases in current reference
                fprintf(out_fp, "|VBS:");
                for (k = 0, printed_vb = 0; bmap[j].nts[k] && k < MAXLEN; k++) {
                    if (bmap[j].nts[k] == '*') {  //if nucletide is variable
                        if (printed_vb) {         //if a variable base has already been printed
                            fprintf(out_fp, "_"); //print an underscore delimiter
                        } else {                  //otherwise
                            printed_vb = 1;       //set flag that the first variable base was printed
                        }
                        
                        mk_vbase_nm(&bmap[j], k, vb_nm, MAX_VBASE_NAME_FIELD+1, '\0'); //assemble vbase name
                        fprintf(out_fp, "%s", vb_nm); //print vbase name to file
                    }
                }
                
                if (bmap[j].ci_cnt || bmap[j].d_cnt) {
                    fprintf(out_fp, "|const:");
                    
                    //print constant insertions
                    for (c = 0; c < bmap[j].ci_cnt; c++) {
                        mk_vbase_nm(&bmap[j], bmap[j].ci_ix[c], vb_nm, MAX_VBASE_NAME_FIELD+1, '\0'); //assemble vbase name
                        fprintf(out_fp,"%s", vb_nm);                      //print vbase_name to file
                        if (c+1 < bmap[j].ci_cnt || bmap[j].d_cnt) { //check if there are more constants to print
                            fprintf(out_fp, "_");                    //if so, print '_' delimiter
                        }
                        
                    }
                    
                    //print constant deletions
                    for (d = 0; d < bmap[j].d_cnt; d++) {
                        mk_vbase_nm(&bmap[j], bmap[j].d_ix[d], vb_nm, MAX_VBASE_NAME_FIELD+1, '\0'); //assemble vbase name
                        fprintf(out_fp, "%s", vb_nm);    //print vbase_name to file
                        if (d+1 < bmap[j].d_cnt) { //check if there are more deletions to print
                            fprintf(out_fp, "_");  //if so, print '_' delimiter
                        }
                    }
                }
                
                fprintf(out_fp, "\t%s\n", vrnts[i].sq); //print reference sequence
                j++;                                    //increment basemap index
                
            } else {
                printf("print_output: error - >%d reference targets were generated for %d variant templates. aborting...\n", j, vTmpCnt);
                abort();
            }
        } else {
            if (append_barcode) { //print variant sequence that contains a barcode
                print_barcoded_variant(fp_brcd, out_fp, fasta_fp, append_priming, cstm_lnkr, vTmpCnt, i, bcs_per_var, first_bc_2_use, make_fasta);
            } else { //print variant sequence that does not contain a barcode
                print_standard_variant(out_fp, fasta_fp, append_priming, i, make_fasta);
            }
        }
    }
    
    //close output file
    if (fclose(out_fp) == EOF) {
        printf("print_output: error - error occurred when closing variant output file. Aborting program...\n");
        abort();
    }
    
    //close fasta file
    if (make_fasta) {
        if (fclose(fasta_fp) == EOF) {
            printf("print_output: error - error occurred when closing variant fasta file. Aborting program...\n");
            abort();
        }
    }
    
    return;
}

/* print_standard_variant: print variant sequence that does not contain a barcode */
void print_standard_variant(FILE * out_fp, FILE * fasta_fp, int append_priming, int crrnt_var, int make_fasta)
{
    extern fasta *vrnts;    //array of variant sequences
    extern uint64_t v_indx; //index for vrnts array
    
    extern char * fwd2use;  //forward priming site to use
    extern char * rev2use;  //reverse priming site to use
        
    int i = 0; //general purpose index
     
    char seq[MAX_LINE+1] = {0};  //array to store sequence
    int len = 0;                 //length of sequence
    
    //calculate output sequence length
    len += strlen(vrnts[crrnt_var].sq);
    len += append_priming ? (strlen(fwd2use) + strlen(rev2use)) : 0;
    
    if (len >= MAX_LINE) { //check that output sequence will fit in array
        printf("print_barcoded_variant: ERROR - sequence is too long (%d nucleotides). aborting\n", len);
    }

    //assemble output sequence
    if (append_priming) {             //if appending priming sites
        strcat(seq, fwd2use);         //append the forward priming site sequence
    }
    
    strcat(seq, vrnts[crrnt_var].sq); //append variant sequence
    
    if (append_priming) {             //if appending priming sites
        strcat(seq, rev2use);         //append the reverse priming site sequence
    }
    
    //print output sequence to file(s)
    fprintf(out_fp, "%s\t%s\n", vrnts[crrnt_var].nm, seq); //print variant to standard output file
    
    if (make_fasta) {
        fprintf(fasta_fp, ">%s\n%s\n", vrnts[crrnt_var].nm, seq); //print variant to fasta file
    }
}

/* print_barcoded_variant: print variant that contains barcode */
void print_barcoded_variant(FILE * fp_brcd, FILE * out_fp, FILE * fasta_fp, int append_priming, char * cstm_lnkr, int vTmpCnt, int crrnt_var, int bcs_per_var, int first_bc_2_use, int make_fasta)
{
    extern fasta *vrnts;    //array of variant sequences
    extern uint64_t v_indx; //index for vrnts array
    
    extern char * fwd2use;  //forward priming site to use
    extern char * rev2use;  //reverse priming site to use
    
    int i = 0; //general purpose index
    
    static int bc_cnt = 0;              //barcode count
    
    char crrnt_bc[MAX_LINE+1] = {0};    //current barcode
    static int bc_indx = 0;             //current barcode index
    
    static int incld_lnkr = 1;          //flag to include linker
    static char lnkr[MAX_LINE+1] = {0}; //linker sequence
    
    if (crrnt_var == 1) {                            //if processing first variant
        bc_cnt = read_bcFile(fp_brcd, HEADER, lnkr); //parse barcode file header
        
        if (first_bc_2_use > bc_cnt) { //check that first barcode id to use is less than max barcode id
            printf("print_barcoded_variant: ERROR - id of first barcode to use cannot be greater than the number of barcodes provided in the barcodes file. aborting...\n");
            abort();
        } else {
            for (i = 1; i < first_bc_2_use; i++) {
                if ((bc_indx = read_bcFile(fp_brcd, BC_LINE, crrnt_bc)) == -1) { //get barcode
                    printf("print_output: ERROR - too few barcodes. %llu barcodes are required to barcode each variant %d times. aborting...\n", (long long unsigned int)((v_indx-vTmpCnt)*bcs_per_var), bcs_per_var);
                    abort();
                }
            }
        }
        
        //set linker
        if (cstm_lnkr[0]) {                        //if using custom linker
            if (!strcmp(cstm_lnkr, "exclude")) {   //if excluding linker
                incld_lnkr = 0;                    //set include linker flag to false
            } else {
                strcpy(lnkr, cstm_lnkr);           //otherwise, set custom linker
            }
        }
    }
    
    char seq[MAX_LINE+1] = {0}; //output sequence
    int len = 0;                //length of output sequence
    
    for (i = 0; i < bcs_per_var; i++) { //run loop for every barcode that will be assigned to the variant
        
        seq[0] = '\0'; //reset seq array
        
        if ((bc_indx = read_bcFile(fp_brcd, BC_LINE, crrnt_bc)) == -1) { //get barcode
            printf("print_output: ERROR - too few barcodes. %llu barcodes are required to barcode each variant %d times. aborting...\n", (long long unsigned int)((v_indx-vTmpCnt)*bcs_per_var), bcs_per_var);
            abort();
            
        } else {
            //calculate output sequence length
            len += strlen(vrnts[crrnt_var].sq);
            len += append_priming ? (strlen(fwd2use) + strlen(rev2use)) : 0;
            len += incld_lnkr ? strlen(lnkr) : 0;
            len += strlen(crrnt_bc);
            
            if (len >= MAX_LINE) { //check that sequence will fit in array
                printf("print_barcoded_variant: ERROR - sequence is too long (%d nucleotides). aborting...\n", len);
            }

            //assemble output sequence
            if (append_priming) {             //if appending priming sites
                strcat(seq, fwd2use);         //append the forward priming site sequence
            }
            strcat(seq, vrnts[crrnt_var].sq); //append variant sequence
            if (incld_lnkr) {                 //if including linker sequence
                strcat(seq, lnkr);            //append linker sequence
            }
            strcat(seq, crrnt_bc);            //append barcode
            if (append_priming) {             //if appending priming sites
                strcat(seq, rev2use);         //append the reverse priming site sequence
            }
            
            
            fprintf(out_fp, "%s_%d\t%s\n", vrnts[crrnt_var].nm, bc_indx, seq); //print variant to standard output file
            if (make_fasta) {
                fprintf(fasta_fp, ">%s_%d\n%s\n", vrnts[crrnt_var].nm, bc_indx, seq); //print variant to fasta file
            }
        }
    }
}
